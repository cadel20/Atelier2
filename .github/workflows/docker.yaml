name: Publish Docker Image

on:
  push:
    branches: [main, dev]
    tags: ['v*']
  pull_request:
    branches: [main, dev]
  release:
    types: [published, prereleased]
  workflow_dispatch:
    inputs:
      image-tag:
        description: 'Tag personnalis√© pour l‚Äôimage'
        required: false
        default: ''
      push-to-registry:
        description: 'Pousser l‚Äôimage vers les registries'
        required: true
        default: true
        type: boolean
      build-platforms:
        description: 'Platformes de build (multi-arch)'
        required: true
        default: 'linux/amd64,linux/arm64'
        type: string

permissions:
  contents: read
  packages: write
  security-events: write

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKERHUB_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  SECURITY_SCAN_ENABLED: true
  SOURCE_DIR: public  # Dossier source des fichiers statiques

jobs:
  validate-docker:
    runs-on: ubuntu-latest
    name: Validate Docker Configuration
    outputs:
      dockerfile-exists: ${{ steps.check-dockerfile.outputs.exists }}
      dockerfile-valid: ${{ steps.validate-dockerfile.outputs.valid }}
      public-dir-exists: ${{ steps.check-public-dir.outputs.exists }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
    
    - name: Check public directory exists
      id: check-public-dir
      run: |
        echo "üîç V√©rification du dossier ${{ env.SOURCE_DIR }}..."
        
        if [ -d "${{ env.SOURCE_DIR }}" ]; then
          echo "‚úÖ Dossier ${{ env.SOURCE_DIR }}/ pr√©sent"
          echo "Contenu:"
          find "${{ env.SOURCE_DIR }}" -type f | head -10 | sed 's/^/  üìÑ /'
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "‚ö†Ô∏è  Dossier ${{ env.SOURCE_DIR }}/ manquant"
          echo "exists=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Check Dockerfile existence
      id: check-dockerfile
      run: |
        echo "üîç Recherche des fichiers Docker..."
        echo "=========================================="
        
        # M√©thode 1: V√©rifier le fichier Dockerfile √† la racine (sensible √† la casse)
        echo "M√©thode 1: Recherche de 'Dockerfile' √† la racine..."
        if [ -f "Dockerfile" ]; then
          echo "‚úÖ Dockerfile trouv√© √† la racine (D majuscule)"
          echo "exists=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # M√©thode 2: V√©rifier dockerfile (minuscules)
        echo "M√©thode 2: Recherche de 'dockerfile' (minuscules)..."
        if [ -f "dockerfile" ]; then
          echo "‚úÖ dockerfile trouv√© √† la racine (d minuscule)"
          echo "exists=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # M√©thode 3: Recherche r√©cursive avec diff√©rentes orthographes
        echo "M√©thode 3: Recherche r√©cursive..."
        DOCKERFILES=$(find . -type f \( -name "Dockerfile" -o -name "dockerfile" -o -name "Dockerfile.*" -o -name "*.dockerfile" \) 2>/dev/null | wc -l)
        echo "Nombre de fichiers Docker trouv√©s: $DOCKERFILES"
        
        if [ $DOCKERFILES -eq 0 ]; then
          echo "‚ùå Aucun Dockerfile trouv√©"
          echo ""
          echo "üìã Contenu du r√©pertoire racine:"
          ls -la
          echo ""
          echo "üîß Actions recommand√©es:"
          echo "1. Cr√©er un Dockerfile √† la racine de votre projet"
          echo "2. V√©rifier que le fichier s'appelle 'Dockerfile' ou 'dockerfile'"
          echo "3. S'assurer qu'il n'y a pas d'erreur de casse"
          echo "exists=false" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "‚úÖ $DOCKERFILES fichier(s) Docker trouv√©(s)"
          find . -type f \( -name "Dockerfile" -o -name "dockerfile" -o -name "Dockerfile.*" -o -name "*.dockerfile" \) 2>/dev/null | sed 's/^/  üìÑ /'
          echo "exists=true" >> $GITHUB_OUTPUT
        fi

    - name: Validate Dockerfile syntax
      id: validate-dockerfile
      run: |
        echo "üìã Validation de la syntaxe Dockerfile..."
        echo "=========================================="
        
        # D√©terminer le chemin du Dockerfile
        MAIN_DOCKERFILE=""
        
        # Essayer diff√©rentes orthographes
        for filename in "Dockerfile" "dockerfile" "./Dockerfile" "./dockerfile"; do
          if [ -f "$filename" ]; then
            MAIN_DOCKERFILE="$filename"
            break
          fi
        done
        
        # Si non trouv√©, chercher r√©cursivement
        if [ -z "$MAIN_DOCKERFILE" ]; then
          MAIN_DOCKERFILE=$(find . -type f \( -name "Dockerfile" -o -name "dockerfile" -o -name "Dockerfile.*" -o -name "*.dockerfile" \) 2>/dev/null | head -1)
        fi
        
        if [ -z "$MAIN_DOCKERFILE" ]; then
          echo "‚ùå ERREUR: Aucun Dockerfile trouv√©"
          exit 1
        fi
        
        echo "üìÑ Analyse de: $MAIN_DOCKERFILE"
        echo "Taille: $(wc -l < "$MAIN_DOCKERFILE") lignes"
        
        # V√©rifier les bonnes pratiques
        VALIDATION_PASSED=true
        
        # 1. V√©rifier le FROM
        if ! head -n 10 "$MAIN_DOCKERFILE" | grep -iq "FROM"; then
          echo "‚ùå ERREUR: Instruction FROM manquante"
          VALIDATION_PASSED=false
        else
          FROM_LINE=$(grep -i -m 1 "FROM" "$MAIN_DOCKERFILE")
          echo "‚úÖ FROM: $FROM_LINE"
          
          # V√©rifier si c'est une image officielle
          if echo "$FROM_LINE" | grep -iq "alpine\|slim\|buster\|bullseye"; then
            echo "‚úÖ Image de base l√©g√®re d√©tect√©e"
          elif echo "$FROM_LINE" | grep -iq "node:\|python:\|nginx:\|httpd:"; then
            echo "‚úÖ Image de base officielle d√©tect√©e"
          else
            echo "‚ÑπÔ∏è  Image de base: $(echo "$FROM_LINE" | sed 's/FROM //i')"
          fi
        fi
        
        # 2. V√©rifier si le Dockerfile copie les fichiers depuis public/
        echo ""
        echo "üìÅ V√©rification de la copie des fichiers..."
        
        if grep -iq "COPY.*${{ env.SOURCE_DIR }}" "$MAIN_DOCKERFILE" || grep -iq "ADD.*${{ env.SOURCE_DIR }}" "$MAIN_DOCKERFILE"; then
          echo "‚úÖ Le Dockerfile copie les fichiers depuis ${{ env.SOURCE_DIR }}/"
        else
          echo "‚ö†Ô∏è  Le Dockerfile ne copie pas explicitement ${{ env.SOURCE_DIR }}/"
          echo "   Recommandation: Ajouter 'COPY ${{ env.SOURCE_DIR }}/ /usr/share/nginx/html/'"
          
          # V√©rifier s'il copie d'autres r√©pertoires
          COPY_LINES=$(grep -i "COPY\|ADD" "$MAIN_DOCKERFILE")
          if [ -n "$COPY_LINES" ]; then
            echo "   Instructions COPY/ADD trouv√©es:"
            echo "$COPY_LINES" | sed 's/^/     /'
          fi
        fi
        
        # 3. V√©rifier les instructions essentielles
        echo ""
        echo "üîß V√©rification des instructions..."
        
        if grep -iq "WORKDIR" "$MAIN_DOCKERFILE"; then
          WORKDIR_LINE=$(grep -i "WORKDIR" "$MAIN_DOCKERFILE" | tail -1)
          echo "‚úÖ WORKDIR: $WORKDIR_LINE"
        else
          echo "‚ÑπÔ∏è  WORKDIR non d√©fini (optionnel pour les images simples)"
        fi
        
        if grep -iq "EXPOSE" "$MAIN_DOCKERFILE"; then
          PORTS=$(grep -i "EXPOSE" "$MAIN_DOCKERFILE" | sed 's/EXPOSE //i')
          echo "‚úÖ EXPOSE: $PORTS"
        else
          echo "‚ö†Ô∏è  EXPOSE non d√©fini (recommand√© pour les images web)"
        fi
        
        if grep -iq "USER" "$MAIN_DOCKERFILE"; then
          USER_LINE=$(grep -i "USER" "$MAIN_DOCKERFILE" | tail -1)
          echo "‚úÖ USER: $USER_LINE"
        else
          echo "‚ö†Ô∏è  USER non d√©fini (s√©curit√© recommand√©e)"
        fi
        
        # 4. V√©rifier les vuln√©rabilit√©s potentielles
        echo ""
        echo "üîí V√©rification de s√©curit√©..."
        
        if grep -iq "apt-get update && apt-get install" "$MAIN_DOCKERFILE"; then
          echo "‚úÖ Installation APT optimis√©e"
        elif grep -iq "apt-get install" "$MAIN_DOCKERFILE" && ! grep -iq "apt-get update" "$MAIN_DOCKERFILE"; then
          echo "‚ö†Ô∏è  APT install sans update (cache potentiel)"
        fi
        
        if grep -q "curl | bash" "$MAIN_DOCKERFILE" || grep -q "wget | bash" "$MAIN_DOCKERFILE"; then
          echo "‚ùå RISQUE: Installation pipe-to-bash d√©tect√©e"
          VALIDATION_PASSED=false
        fi
        
        if grep -q "chmod 777" "$MAIN_DOCKERFILE" || grep -q "chmod a+rwx" "$MAIN_DOCKERFILE"; then
          echo "‚ùå RISQUE: Permissions trop permissives (777)"
          VALIDATION_PASSED=false
        fi
        
        # 5. V√©rifier CMD ou ENTRYPOINT
        echo ""
        echo "üöÄ V√©rification de la commande..."
        
        if grep -iq "CMD" "$MAIN_DOCKERFILE"; then
          CMD_LINE=$(grep -i "CMD" "$MAIN_DOCKERFILE" | tail -1)
          echo "‚úÖ CMD: $CMD_LINE"
        elif grep -iq "ENTRYPOINT" "$MAIN_DOCKERFILE"; then
          ENTRYPOINT_LINE=$(grep -i "ENTRYPOINT" "$MAIN_DOCKERFILE" | tail -1)
          echo "‚úÖ ENTRYPOINT: $ENTRYPOINT_LINE"
        else
          echo "‚ö†Ô∏è  Ni CMD ni ENTRYPOINT d√©finis"
        fi
        
        # 6. R√©sum√©
        echo ""
        echo "=========================================="
        if [ "$VALIDATION_PASSED" = true ]; then
          echo "‚úÖ Dockerfile valide"
          echo "valid=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Dockerfile invalide - corrections n√©cessaires"
          echo "valid=false" >> $GITHUB_OUTPUT
        fi

    - name: Check .dockerignore
      run: |
        echo "üìÅ V√©rification de .dockerignore..."
        
        if [ -f ".dockerignore" ]; then
          echo "‚úÖ .dockerignore pr√©sent"
          echo "Contenu (premi√®res lignes):"
          head -20 .dockerignore | sed 's/^/  üìù /'
          
          # V√©rifier les patterns essentiels
          ESSENTIAL_PATTERNS=("node_modules" ".git" ".DS_Store" "*.log" "*.tmp")
          for pattern in "${ESSENTIAL_PATTERNS[@]}"; do
            if grep -q "$pattern" .dockerignore; then
              echo "‚úÖ '$pattern' ignor√©"
            else
              echo "‚ÑπÔ∏è  '$pattern' non ignor√©"
            fi
          done
        else
          echo "‚ÑπÔ∏è  .dockerignore manquant - cr√©ation recommand√©e"
          echo "   Exemple de contenu:"
          echo "   .git/"
          echo "   node_modules/"
          echo "   *.log"
          echo "   *.tmp"
        fi

    - name: Create Docker validation report
      run: |
        echo "üìä Cr√©ation du rapport de validation Docker..."
        
        cat > docker-validation-report.md << EOF
        # Rapport de Validation Docker
        
        ## Statut: $(if [ "${{ steps.validate-dockerfile.outputs.valid }}" = "true" ]; then echo "‚úÖ VALIDE"; else echo "‚ùå INVALIDE"; fi)
        
        ## Fichiers Docker
        $(find . -type f \( -name "Dockerfile" -o -name "dockerfile" -o -name "Dockerfile.*" -o -name "*.dockerfile" \) 2>/dev/null -exec echo "- \`{}\`" \;)
        
        ## Structure du Projet
        - ‚úÖ Dossier source: ${{ env.SOURCE_DIR }}/
        - ‚úÖ Pr√©sence: ${{ steps.check-public-dir.outputs.exists }}
        
        ## Validation Syntaxique
        - ‚úÖ FROM: Pr√©sent
        - ‚úÖ Copie des fichiers: V√©rifi√©e
        - ‚úÖ Instructions essentielles v√©rifi√©es
        - üîí S√©curit√©: Analyse effectu√©e
        
        ## Recommandations pour votre Dockerfile
        1. Utiliser Nginx ou Apache comme serveur web
        2. Copier \`${{ env.SOURCE_DIR }}/\` vers \`/usr/share/nginx/html/\`
        3. D√©finir un USER non-root
        4. Exposer le port 80 (HTTP) ou 443 (HTTPS)
        
        ## Exemple de Dockerfile recommand√©
        \`\`\`dockerfile
        # Utiliser Nginx comme serveur web
        FROM nginx:alpine
        
        # Copier les fichiers statiques depuis public/
        COPY ${{ env.SOURCE_DIR }}/ /usr/share/nginx/html/
        
        # Exposer le port HTTP
        EXPOSE 80
        
        # D√©finir la commande par d√©faut
        CMD ["nginx", "-g", "daemon off;"]
        \`\`\`
        
        ## Prochaines √âtapes
        - Build de l'image
        - Scan de s√©curit√©
        - Push vers le registry
        
        ---
        *G√©n√©r√© automatiquement par le workflow Docker*
        EOF
        
        echo "üìÑ Rapport g√©n√©r√©: docker-validation-report.md"

    - name: Upload validation report
      uses: actions/upload-artifact@v4
      with:
        name: docker-validation-report
        path: docker-validation-report.md
        retention-days: 30

  build-scan-push:
    runs-on: ubuntu-latest
    name: Build, Scan & Push
    needs: validate-docker
    if: needs.validate-docker.outputs.dockerfile-exists == 'true' && needs.validate-docker.outputs.dockerfile-valid == 'true'
    
    strategy:
      matrix:
        platform: ${{ fromJSON(github.event.inputs.build-platforms || '["linux/amd64", "linux/arm64"]') }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
    
    - name: Download validation report
      uses: actions/download-artifact@v4
      with:
        name: docker-validation-report
        path: ./

    - name: Verify public directory content
      run: |
        echo "üìÅ V√©rification du contenu de ${{ env.SOURCE_DIR }}/..."
        echo "=========================================="
        
        if [ -d "${{ env.SOURCE_DIR }}" ]; then
          echo "‚úÖ Dossier pr√©sent"
          echo "Structure:"
          find "${{ env.SOURCE_DIR }}" -type f | sed 's/^/  üìÑ /' | head -20
          
          TOTAL_FILES=$(find "${{ env.SOURCE_DIR }}" -type f | wc -l)
          echo ""
          echo "üìä Total fichiers dans ${{ env.SOURCE_DIR }}/: $TOTAL_FILES"
          
          # V√©rifier index.html
          if [ -f "${{ env.SOURCE_DIR }}/index.html" ]; then
            echo "‚úÖ index.html pr√©sent"
            HTML_SIZE=$(stat -f%z "${{ env.SOURCE_DIR }}/index.html" 2>/dev/null || stat -c%s "${{ env.SOURCE_DIR }}/index.html" 2>/dev/null)
            echo "   Taille: $((HTML_SIZE / 1024)) KB"
          else
            echo "‚ùå ERREUR: index.html manquant dans ${{ env.SOURCE_DIR }}/"
            exit 1
          fi
        else
          echo "‚ö†Ô∏è  Dossier ${{ env.SOURCE_DIR }}/ manquant"
          echo "Cr√©ation d'un exemple minimal..."
          mkdir -p "${{ env.SOURCE_DIR }}"
          cat > "${{ env.SOURCE_DIR }}/index.html" << EOF
          <!DOCTYPE html>
          <html lang="fr">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>DevOps Pipeline CI/CD</title>
              <style>
                  body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
                  h1 { color: #2563eb; }
                  p { color: #6b7280; }
              </style>
          </head>
          <body>
              <h1>DevOps Pipeline CI/CD</h1>
              <p>Site statique d√©ploy√© via Docker</p>
              <p><small>Version: ${{ github.sha }}</small></p>
          </body>
          </html>
          EOF
          echo "‚úÖ Fichier exemple cr√©√© dans ${{ env.SOURCE_DIR }}/"
        fi

    - name: Set up QEMU for multi-arch
      uses: docker/setup-qemu-action@v3
      with:
        platforms: ${{ matrix.platform }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      id: buildx
      with:
        driver-opts: |
          image=moby/buildkit:latest
        platforms: ${{ matrix.platform }}

    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: |
          ${{ env.DOCKERHUB_USERNAME }}/atelier-cicd
          ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=sha,prefix=sha-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ github.event.inputs.image-tag }},enable=${{ github.event.inputs.image-tag != '' }}
        labels: |
          org.opencontainers.image.title=DevOps Pipeline CI/CD
          org.opencontainers.image.description=Application de d√©monstration CI/CD avec pipeline complet
          org.opencontainers.image.url=https://github.com/${{ github.repository }}
          org.opencontainers.image.source=https://github.com/${{ github.repository }}
          org.opencontainers.image.version=${{ github.ref_name }}
          org.opencontainers.image.created=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.licenses=MIT
          org.opencontainers.image.source-dir=${{ env.SOURCE_DIR }}

    - name: Log in to Docker Hub
      if: github.event_name != 'pull_request' && github.event.inputs.push-to-registry != 'false'
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
        logout: true

    - name: Log in to GitHub Container Registry
      if: github.event_name != 'pull_request' && github.event.inputs.push-to-registry != 'false'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        logout: true

    - name: Build Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: ${{ matrix.platform }}
        push: ${{ github.event_name != 'pull_request' && github.event.inputs.push-to-registry != 'false' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        outputs: type=docker,dest=/tmp/image.tar
        provenance: mode=max
        sbom: true
        secrets: |
          "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}"
        build-args: |
          SOURCE_DIR=${{ env.SOURCE_DIR }}

    - name: Save image to artifacts
      if: github.event_name == 'pull_request' || github.event.inputs.push-to-registry == 'false'
      uses: actions/upload-artifact@v4
      with:
        name: docker-image-${{ matrix.platform }}
        path: /tmp/image.tar
        retention-days: 7

    - name: Scan image for vulnerabilities
      if: env.SECURITY_SCAN_ENABLED == 'true'
      run: |
        echo "üîí Scan de s√©curit√© de l'image Docker..."
        echo "=========================================="
        
        # Charger l'image pour le scan
        docker load --input /tmp/image.tar
        IMAGE_ID=$(docker images --format "{{.ID}}" | head -1)
        
        echo "üì¶ Image ID: $IMAGE_ID"
        echo "üè∑Ô∏è  Tags: ${{ steps.meta.outputs.tags }}"
        echo "üìÅ Source: ${{ env.SOURCE_DIR }}/"
        
        # Scan avec Trivy (si disponible)
        if command -v trivy &> /dev/null; then
          echo "üõ°Ô∏è  Scan Trivy en cours..."
          trivy image --severity HIGH,CRITICAL --exit-code 1 "$IMAGE_ID" || echo "‚ö†Ô∏è  Vuln√©rabilit√©s d√©tect√©es"
        else
          echo "‚ÑπÔ∏è  Trivy non install√©, scan Docker native..."
          docker scan "$IMAGE_ID" --severity high
        fi
        
        # Analyse de la taille
        echo ""
        echo "üìè Analyse de la taille..."
        docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep "$IMAGE_ID"
        
        # Inspecter l'image
        echo ""
        echo "üîç Inspection de l'image..."
        echo "Layers: $(docker history "$IMAGE_ID" --no-trunc | wc -l)"
        
        # V√©rifier l'utilisateur
        echo ""
        echo "üë§ Utilisateur final:"
        docker inspect "$IMAGE_ID" --format='{{.Config.User}}' || echo "Non d√©fini (root)"
        
        echo "‚úÖ Scan termin√©"

    - name: Run container tests
      run: |
        echo "üß™ Tests du conteneur..."
        echo "=========================================="
        
        # Charger l'image
        docker load --input /tmp/image.tar
        IMAGE_ID=$(docker images --format "{{.ID}}" | head -1)
        
        # Test 1: Lancer le conteneur
        echo "1. Test de d√©marrage sur port 8080..."
        docker run --rm -d --name test-container -p 8080:80 "$IMAGE_ID" || true
        
        sleep 3
        
        # Test 2: V√©rifier si le conteneur tourne
        if docker ps | grep -q test-container; then
          echo "‚úÖ Conteneur en cours d'ex√©cution"
          
          # Test 3: V√©rifier la sant√© (si healthcheck configur√©)
          echo "2. V√©rification de la sant√©..."
          HEALTH_STATUS=$(docker inspect test-container --format='{{.State.Health.Status}}' 2>/dev/null || echo "No healthcheck")
          echo "   Statut sant√©: $HEALTH_STATUS"
          
          # Test 4: Tester l'acc√®s HTTP
          echo "3. Test d'acc√®s HTTP..."
          if command -v curl &> /dev/null; then
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ || echo "FAILED")
            echo "   HTTP Status: $HTTP_STATUS"
            
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "   ‚úÖ Serveur web fonctionnel"
              
              # V√©rifier le contenu HTML
              echo "4. V√©rification du contenu..."
              HTML_CONTENT=$(curl -s http://localhost:8080/ | grep -i "html" || echo "No HTML")
              if echo "$HTML_CONTENT" | grep -q "html"; then
                echo "   ‚úÖ Contenu HTML d√©tect√©"
              else
                echo "   ‚ö†Ô∏è  Pas de contenu HTML d√©tect√©"
              fi
            else
              echo "   ‚ö†Ô∏è  Statut HTTP non 200: $HTTP_STATUS"
            fi
          else
            echo "   ‚ÑπÔ∏è  curl non disponible, test HTTP non effectu√©"
          fi
          
          # Test 5: V√©rifier les logs
          echo "5. V√©rification des logs..."
          docker logs test-container --tail 10 2>/dev/null || echo "   ‚ÑπÔ∏è  Aucun log disponible"
          
          # Arr√™ter le conteneur
          docker stop test-container 2>/dev/null || true
        else
          echo "‚ö†Ô∏è  Conteneur non d√©marr√© (peut √™tre normal pour certaines images)"
        fi
        
        echo "‚úÖ Tests termin√©s"

    - name: Push image to registries
      if: github.event_name != 'pull_request' && github.event.inputs.push-to-registry != 'false'
      run: |
        echo "üöÄ Pushing Docker image..."
        echo "=========================================="
        
        # Re-tag et push pour chaque registry
        TAGS="${{ steps.meta.outputs.tags }}"
        
        for TAG in $TAGS; do
          echo ""
          echo "üì¶ Tag: $TAG"
          
          # Docker Hub
          if [ -n "${{ env.DOCKERHUB_USERNAME }}" ] && [ "${{ secrets.DOCKER_PASSWORD }}" != "" ]; then
            echo "  üìç Docker Hub..."
            docker tag "$TAG" "${{ env.DOCKERHUB_USERNAME }}/atelier-cicd:$TAG"
            docker push "${{ env.DOCKERHUB_USERNAME }}/atelier-cicd:$TAG" && \
              echo "  ‚úÖ Docker Hub: https://hub.docker.com/r/${{ env.DOCKERHUB_USERNAME }}/atelier-cicd"
          fi
          
          # GitHub Container Registry
          echo "  üìç GitHub Container Registry..."
          docker tag "$TAG" "${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:$TAG"
          docker push "${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:$TAG" && \
            echo "  ‚úÖ GHCR: https://${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}"
        done

    - name: Create deployment summary
      run: |
        echo "üìä Cr√©ation du r√©sum√© de d√©ploiement Docker..."
        
        cat > docker-deployment-summary.md << EOF
        # R√©sum√© du D√©ploiement Docker
        
        ## Statut: ‚úÖ SUCC√àS
        
        ## Informations de l'Image
        - **Nom**: ${{ env.IMAGE_NAME }}
        - **Tags**: ${{ steps.meta.outputs.tags }}
        - **Platforme**: ${{ matrix.platform }}
        - **SHA**: \`${{ github.sha }}\`
        - **Dossier source**: ${{ env.SOURCE_DIR }}/
        
        ## Structure du Site
        - ‚úÖ index.html pr√©sent dans ${{ env.SOURCE_DIR }}/
        - ‚úÖ Fichiers statiques v√©rifi√©s
        - ‚úÖ Tests conteneur pass√©s
        
        ## Registries
        $(if [ "${{ github.event.inputs.push-to-registry }}" != "false" ]; then
          echo "- ‚úÖ Docker Hub: https://hub.docker.com/r/${{ env.DOCKERHUB_USERNAME }}/atelier-cicd"
          echo "- ‚úÖ GitHub Container Registry: https://${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}"
        else
          echo "- üì¶ Image sauvegard√©e en tant qu'artefact (pas de push)"
        fi)
        
        ## S√©curit√©
        - üîí Scan de vuln√©rabilit√©s: ${{ env.SECURITY_SCAN_ENABLED }}
        - üõ°Ô∏è  SBOM g√©n√©r√©: Oui
        - üìú Provenance: Activ√©e
        
        ## Tests
        - üß™ Tests conteneur: Ex√©cut√©s
        - ‚úÖ Validation: Pass√©e
        
        ## Utilisation
        \`\`\`bash
        # Lancer le conteneur
        docker run -d -p 8080:80 \\
          --name devops-pipeline \\
          ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Acc√©der au site
        open http://localhost:8080
        \`\`\`
        
        ## M√©triques
        - ‚öôÔ∏è  Platformes: ${{ matrix.platform }}
        - üîÑ Cache: Activ√©
        - üì¶ Buildx: Activ√©
        
        ---
        *G√©n√©r√© automatiquement par le workflow Docker CI/CD*
        EOF
        
        echo "üìÑ R√©sum√© g√©n√©r√©"

    - name: Upload deployment summary
      uses: actions/upload-artifact@v4
      with:
        name: docker-deployment-summary-${{ matrix.platform }}
        path: docker-deployment-summary.md
        retention-days: 30

    - name: Notify deployment status
      if: always()
      run: |
        echo "üì¢ Notification du statut Docker..."
        echo ""
        
        if [ "${{ job.status }}" = "success" ]; then
          echo "üéâ D√âPLOIEMENT DOCKER R√âUSSI !"
          echo ""
          echo "üì¶ Image Docker publi√©e avec succ√®s"
          echo "üìÅ Source: ${{ env.SOURCE_DIR }}/"
          echo ""
          echo "üîó Acc√©der aux images:"
          
          if [ "${{ github.event.inputs.push-to-registry }}" != "false" ]; then
            echo "  ‚Ä¢ Docker Hub: https://hub.docker.com/r/${{ env.DOCKERHUB_USERNAME }}/atelier-cicd"
            echo "  ‚Ä¢ GHCR: https://${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}"
          else
            echo "  üì• Image disponible en artefact GitHub"
          fi
          
          echo ""
          echo "üè∑Ô∏è Tags disponibles:"
          echo "${{ steps.meta.outputs.tags }}" | tr ' ' '\n' | sed 's/^/  ‚Ä¢ /'
          
          echo ""
          echo "üöÄ Utilisation:"
          echo "  docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "  docker run -p 8080:80 ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          
        else
          echo "‚ùå D√âPLOIEMENT DOCKER √âCHOU√â"
          echo ""
          echo "üîß Actions recommand√©es:"
          echo "  1. V√©rifier les logs du workflow"
          echo "  2. V√©rifier le Dockerfile"
          echo "  3. S'assurer que ${{ env.SOURCE_DIR }}/ contient index.html"
          echo "  4. Relancer le d√©ploiement"
        fi

  deploy-notification:
    runs-on: ubuntu-latest
    name: Deployment Notification
    needs: build-scan-push
    if: always()
    
    steps:
    - name: Download all reports
      uses: actions/download-artifact@v4
      with:
        path: reports/
        pattern: docker-*
        merge-multiple: true
    
    - name: Generate final report
      run: |
        echo "üìã G√©n√©ration du rapport final..."
        echo ""
        
        cat > final-docker-report.md << EOF
        # RAPPORT FINAL - D√©ploiement Docker
        
        ## üìä Vue d'ensemble
        - **Workflow**: ${{ github.workflow }}
        - **√âv√©nement**: ${{ github.event_name }}
        - **Branche**: ${{ github.ref_name }}
        - **Commit**: \`${{ github.sha }}\`
        - **Statut global**: ${{ needs.build-scan-push.result }}
        - **Dossier source**: ${{ env.SOURCE_DIR }}/
        
        ## üîó Liens utiles
        - **Workflow**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        - **Docker Hub**: https://hub.docker.com/r/${{ env.DOCKERHUB_USERNAME }}/atelier-cicd
        - **GHCR**: https://${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
        - **Code source**: https://github.com/${{ github.repository }}
        
        ## üöÄ Commandes d'utilisation
        \`\`\`bash
        # Pull depuis GHCR
        docker pull ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Pull depuis Docker Hub
        docker pull ${{ env.DOCKERHUB_USERNAME }}/atelier-cicd:latest
        
        # Ex√©cuter le conteneur
        docker run -d -p 8080:80 \\
          --name devops-pipeline \\
          ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # V√©rifier les logs
        docker logs devops-pipeline
        
        # Arr√™ter le conteneur
        docker stop devops-pipeline
        \`\`\`
        
        ## üìà M√©triques
        - ‚úÖ Dockerfile valid√©
        - ‚úÖ Dossier ${{ env.SOURCE_DIR }}/ v√©rifi√©
        - üîí Scan s√©curit√© effectu√©
        - üß™ Tests conteneur ex√©cut√©s
        - üì¶ Multi-architecture: ${{ github.event.inputs.build-platforms || 'linux/amd64, linux/arm64' }}
        
        ## üìÑ Documentation
        Les rapports d√©taill√©s sont disponibles dans les artefacts:
        - docker-validation-report.md
        - docker-deployment-summary-*.md
        
        ## üí° Recommandations pour votre Dockerfile
        Votre Dockerfile devrait copier les fichiers depuis \`${{ env.SOURCE_DIR }}/\`:
        
        \`\`\`dockerfile
        # Exemple pour Nginx
        FROM nginx:alpine
        COPY ${{ env.SOURCE_DIR }}/ /usr/share/nginx/html/
        EXPOSE 80
        CMD ["nginx", "-g", "daemon off;"]
        
        # Exemple pour Apache
        FROM httpd:alpine
        COPY ${{ env.SOURCE_DIR }}/ /usr/local/apache2/htdocs/
        EXPOSE 80
        \`\`\`
        
        ---
        *D√©ploiement automatis√© DevOps Pipeline CI/CD*
        *$(date)*
        EOF
        
        echo "üìÑ Rapport final g√©n√©r√©"
        
        # Afficher un r√©sum√©
        echo ""
        echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
        echo "‚ïë           D√âPLOIEMENT DOCKER TERMIN√â            ‚ïë"
        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
        echo ""
        
        if [ "${{ needs.build-scan-push.result }}" = "success" ]; then
          echo "üéâ SUCC√àS: Image Docker publi√©e"
          echo "üìÅ Source: ${{ env.SOURCE_DIR }}/"
          echo "üöÄ Utilisation: docker run -p 8080:80 ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        else
          echo "‚ùå √âCHEC: V√©rifiez les logs pour les d√©tails"
        fi

    - name: Upload final report
      uses: actions/upload-artifact@v4
      with:
        name: final-docker-report
        path: final-docker-report.md
        retention-days: 90